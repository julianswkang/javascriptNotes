HTML (Hypertext Markup Language) is the raw data that a webpage is built of -- text, links, cards, lists, buttons. Provides basic structure for the web page design and layout 
CSS adds style, position to those plain elements generated by HTML -- provides visual appeal and presentation of the HTML elements to the webpage 
Javascript increases interactivity and handles complex functions/features 

HTML&CSS are not programming languages - there is no logic vs. Javascript, which is used to make webpages do things and make it interactive for users 

Almost all elements on HTML page are pieces of content wrapped in opening and closing HTML tags 
Opening tags tell the browser that it is the start of an HTML element (ex <p>), closing tags signal end of element (ex. </p>)
There are some HTML elementts that do NOT have a closing tag, known as empty elements -- do not wrap any content 
There is content between the opening and closing tags 


Boiler plate for html pages:
<!DOCTYPE html> //tells the browser which version of HTML this is (HTML5)
<html lang="en"> //<html> element = root element of the document, lang = language of text content
  <head> //put meta-information ABOUT our webpages
    <title>My First Webpage</title> //title element is for the webpage browser tab 
    <meta charset="UTF-8"> //meta charset ensures that the webpage will display special characters/symbols correctly
  </head>

  <body> //body is where all of the content that will be displayed to users will go
    <h1>Hello World!</h1>
  </body>
</html>

Shortcut in VScode for boiler plate on HTML file is "!" on the first line of code
Different charsets to use 
    -ASCII -- most basic, but not as popular.. not enough characters 
    -UTF-8 -- industry standard, used for consistency of character encoding 

--Paragraphs
Each time you want to create a paragraph in html, you must use the paragraph element <p></p>

--Headings
There are 6 different levels of headings from <h1> to <h6> (largest to smallest)

--strong
<strong> element makes text bold 

--em ("emphasis")
<em> makes the element italic 

When nesting elements, we create a parent-child relationship between them. To represent this, should indent the child elements 
Elements at the same level of nesting are considered to be siblings 

--Writing comments:
<!-- Comment goes here -->

--Creating lists:
Unordered lists (bullet points) use the <ul></ul> tags
    each item within the list item is created using the element <li></li>
Ordered lists (numbered) use the <ol></ol> tags
    each item also created with <li></li>

--Links and images 
To create a link in HTML, use the anchor element with <a></a> tag
Will need an associated HTML attribute, which always goes in the element's opening tag 
Attributes give additional information to an HTML element
In this case, will need to add an href (hyperlink reference) attribute to the opening anchor tag 
ex. <a href="https://www.google.com">click me</a>
If the href attribute is present, the browser will give the text a blue color and underline to signify that it is a link 

2 kinds of links: absolute vs relative links 
Absolute links = links to other websites on the internet, as seen above
Relative links = links within our own website -- do not include domain name since it is another page on the same site 
    --only include the file path to the other page, relative to the page you are creating the link on 
    ex. <a href="about.html>About</a>
    This will send you to the About page on your web site. the about.html should be in the same directory
    Use the "./" prior to the file name if within the same "level" directory 
    To access the parent "above level" directory, use "../" prior to the file name 

Images 
To display an image in HTML, we use the <img> element -- does not use a closing tag 
Instead of using opening/closing tags, will embed an image into the page using an src attribute, tells the browser where the image file is located 
You can create a new sub directory in the main directory/project 
    if the target image (dog.jpg) is in the images directory, can use: <img src="images/dog.jpg">
Besides the src attribute, should also use an alt attribute --> will be used in place of image if cannot be loaded and also used with screen readers to describe the image 
    ex. <img src="https://www.theodinproject.com/mstile-310x310.png" alt="The Odin Project Logo">
    ex. <img src="images/dog.jpg" alt="Picture of black pug">
4 different image formats you can use on the web
1. jpg - good for handling large color palettes without crazy file sizes **good for photos**
2. gif - good for simple animations
3. png - great for anything that is not a photo or animated **good for diagrams/icons**
4. svg - can scale up or down to ANY dimension without loss of quality **should use whenever possible!**

DOM (document object model) = data representation of the objects that comprise the structure and content of a document on the web
-programming interface for web documents, represents the page so that programs can change the document structure, style, and content 
-the DOM represents the document as nodes/objects so that programming languages can interact with the page 
-as an object oriented representation of the webpage, it can be modified by scripting languages, such as javascript 
  -javascript uses the DOM to access the document and its elements 
-the DOM is built using multiple APIs that work together 
  -the core DOM defines the entities describing any document and objects within it, which is then expanded upon as needed by other APIs that add new features/capabilities to the DOM
-when you use a web browser to request a page, the server returns HTML
  -the browser then processes the HTML and creates a tree of objects or nodes representing the page's content = DOM
  -you can run script that can remove or adds nodes, so that the DOM and HTML differ
  -HTML represents the initial page content, and DOM represents the current content
  -Javascript can add/remove/edit nodes that become different than the HTML
-the DOM allows us to:
  -add/delete/change content to an HTML document
-every HTML element/tag in the DOM is an object (ex. head, body, ul, p, div, etc.)
  -can invoke methods on objects to change/manipulate them
-nodes are everything we can change in the document 
  -elements, text within elements, HTML attributes are all separate nodes can all be changed 

-Traversing the DOM
-in the DOM, can reach in at any node and manipulate it as we need to
-once we have that node, we can traverse into the DOM to access other nodes within that parent node
-get elements by class name: 
  -document.getElementsByClassName('//class name here');
  -if multiple nodes of that class name in the form of an array
  -can store into variables
  -var myContentDivs = document.getElementsByClassName('//class name here');
  -can traverse into that variable 
  -var myH2 = myContentDivs[1].getElementsByTagName('//tag name here');
  -this will still return an array, even if there is only one element that is returned
  -myH2[0].innerHTML = "fdsafdas" --> will change the text within the H2 element that was grabbed
-get elements by ID name:
  -document.getElementById('//ID attribute here')
  -will only return ONE element, not in the form of an array
  -this is because there is only one ID in each document 

-using properties to change content
-innerHTML --> will return the html of the object that is being called
  -ex. if use document.getElementsByTagName('body')[0].innerHTML, will return all of the HTML within the body tags
-textContent --> will return the text within the element that you are invoking upon 
  -this will also allow you change the text content by assigned it other texts
  -ex. myTitle.textContent = "This is a new title" --> will replace the text

-accessing and changing attributes 
-can use getAttribute() and setAttribute() methods on elements 
-.getAttribute() will return the attribute of the element
-.setAttribute() will reassign the class of the given element
  -____.setAttribute('class', 'pie) --> will change current class name to 'pie'
  -____.setAttribute('id','potato') --> will change current id name to 'potato'
  -____.setAttribute('style','position='left'); --> will either add or completely replace the style to what setAttribute sets it to
-can add attributes using the setAttribute method with the same syntax

-changing CSS styles 
  -can also use ___.style.position = 'right';
  -or ___.style.backgroundColor = 'blue';
  -unlike the setAttribute method, will not completely replace the style. will simply add to it 

-adding elements to the DOM
  -will first need to create the element in javascript
  -will then push it into the HTML where we want it

  -ex. want to create a new <li> element
  -let newLi = document.createElement('li');
  -want to create a new <a> to place within that new <li>
  -let newA = document.createElement('a');

  -let menu = document.getElementsById('main-nav').getElementsByTagName('ul')[0];
    -this will allow us to get the child ul element within the parent class, main-nav
  -menu.appendChild(newLi); --> will append new li tag into the ul tag within the main-nav class
  -newLi.appendChild(newA); --> will insert the a tag within the new li tags
  -can use newA.innerHTML = "words" to place text within the a tags 
  -can use newA.setAttribute('href', https://www.google.com); to add href attribute
  -can use menu.insertBefore(newLi,menu.getElementsByTagName('li')[0]); to place the newLi at the top of the ul list

-removing elements from the DOM 
  -need to grab the element to remove and the direct parent tag that the element is within
  -let parent = document.getElementById('main-nav').getElementsByTagName('ul')[0]; 
  -let child = parent.getElementsByTagName('li')[0];
  -let removed = parent.removeChild(child); --> will store the element that we removed in the removed variable, will allow us to re-insert if needed 
    -parent.appendChild(removed); --> will add towards the bottom
    -parent.insertBefore(removed, parent.getElementsByTagName('li')[0]) --> will add to top 


API (application programming interface) = set of features and rules that exist inside a software program (application) that enables interaction with it through software 
  -in web dev, API is generally a set of code features (ex. methods, properites, events, etc.) that a developer can use in their apps for interacting with components of a user's web browser or other software

CSS

CSS is made up of various rules
These rules are made up of a selector and a semi-colon separated list of declarations
  -these declarations are made up of property:value pairs
ex. div.bold-text {
  font-weight: 700;
} //div.bold-text is a selector, font-weight is a property, 700 is a value

<div> is one of the basic HTML elements, which acts simply as an empty container
Selectors simply refer to HTML elements to which CSS rules apply -- they are what is actually being "selected" for each rule 
  -universal selectors --> selects elements of ANY type; syntax: *
    -ex. *{ color: purple;} would result in every element with the color: purple style applied to it 
  -type selectors --> selects all elements given element type,syntax: name of element
    -ex. div {color: white} would result in only div elements would be selected and color: white applied to 
  -class selectors --> selects all elements with the given class (=an attribute you place on an HTML element)
    -ex. <div class ="alert text> Please say hi </div>
        .alert-text {color: red;} --> selects all elements of the class, alert-text, and colorL red would be applied to them
    -with class attributes, can add multiple classes to a single element as a space-separated list, such as class="alert-text severe-alert". Thus should never use spaces in multi-worded names, use hyphen instead 
  -id selectors --> similar to classes, they select an element with the given ID, which is another attribute you place on an HTML element
    -ex. <div id="Title">My title</div>
        #title {background-color: red;} --> all divs with id "Title" will have background color of red
    -major difference between id and classes: an element can only have ONE id. An id can only be repeated on a single page, and the id attribute should have no whitespace at all

Grouping selectors:
  -if selectors share style declarations, can be grouped together:
    .read, .unread {color: white; background-color: black}
    .read{ **unique declarations here}
    .unread{ **unique declarations here}
  -Now, .read and .unread share the same color and background color declarations 

Chaining selectors: 
  -<div>
    <div class="subsection header">Words words</div>
    <p class="subsection preview">Words words words</p>
    </div>
  -.subsection.header{color: red} --> would only apply to elements that have BOTH subsection and header classes 
  -.subsection would apply to both
  -.preview would only apply to "subsection preview"

  Descendent combinator:
  -A descendant combinator will only cause elements that match the last selector to be selected if they also have an ancestor (parent, grandparent, etc) that matches the previous selector.
  -So something like ".ancestor .child" would select an element with the class child if it has an ancestor with the class "ancestor". Another way to think of it is child will only be selected if it is nested inside of "ancestor", no matter how deeply.
  
  <div class="ancestor"> <!-- A -->
    <div class="contents"> <!-- B -->
      <div class="contents"> <!-- C -->
      </div>
    </div>
  </div>
  <div class="contents"></div> <!-- D -->

  /* styles.css */
  .ancestor .contents {
    /* some declarations */
  }
  -in the above example, only the first two elements with the contents class (B and C) would be selected, but that last element (D) would not be


Properties in CSS:
-color = element's text color
-background-color = elements background color 
  -color and background-color can accept keywords, HEX (#1100ff), RGB (100,0,127), and HSL(15, 65%, 23%) values 
-font-family = font an element uses 
-font-size = sets size of font (ex. 22px)
-font-weight = font boldness (increments of 100, up to 900)
-text-align = align text horizontally within an element (ex. text-align: center)
-image height and width - will default to actual image's height and width
  img{
    height: 500px; (can also use auto, to automatically automatically adjust the size while changing the other property)
    width: 500px; (can also use auto here)
  }


Specificity:
-more specific declarations will take precedence over ones that are less specific 
  -id selectors (#) > class selectors (.) > type selectors
-An ID selector will always beat any number of class selectors, a class selector will always beat any number of type selectors, and a type selector will always beat any number of anything less specific than it. 
-When no declaration has a selector with a higher specificity, a larger amount of a single selector will beat a smaller amount of that same selector.
-inline styles have the highest specificity, compared to selectors 

Inheritance:
-css properties, when applied to an element, are inherited by that element's decendants 
-exception will be when there is direct targetting of that child element 

Rule order:
-if there are still multiple conflicting rules targeting an element, whichever rule was last defined will take over

External CSS:
-creating a separate file for the CSS and linking it inside of an HTML's opening and closing <head> tags with a self-clising <link> element
  -ex. <link rel="stylesheet" href="styles.css">
  -href attribute is the location of the css file 
  -rel attribute is required, specifies the relationship between the HTML file and the linked file
-this keeps our HTML and CSS separated, making things look cleaner 

Internal CSS:
-embedded CSS, involves adding the CSS within the HTML file itself instead of creating a completely separate file 
-will be placed inside <style></style> tags, which are placed inside the <head></head> tags of the HTML file 

Inline CSS: 
-add styles directly to the HTML elements (not recommended) -- can get messy
-would be used if you need to add a unique style for a SINGLE element

CSS cascade (https://wattenberger.com/blog/css-cascade) = way our browsers resolve CSS declarations
1. Importance - first tier of the cascade looks at the TYPE of rule we're looking at 
  -4 basic types of rules: 
    1. transition - rules that apply to an active transition take utmost Importance
    2. !important - this will cause a jump to this level of the cascade
    3. animation - rules that apply to an active animation jump up a level in the cascade
    4. normal - where the bulk of rules live

2. Origin - second tier of the cascade, looks at WHERE the the rule was defined 
  1. website
  2. users
  3. browser

3. Specificity - third tier of the cascade, looks at specificity 
  1. inline - declared within a style HTML property (most specific)
  2. layers - layers "win" by being defined later
  3. id - targeting elements with their id, using #id syntax
  4. class / attribute / pseudo-class - targetting based on class, using .class syntax  
    -attribute selectors like [href="https://google.com] using [attribute] syntax
    -pseudo-selectors like :hover, using :pseudo-selectors syntax
  5. type - targetting based on tag type, using the syntax type 
-number of "hits" on the highest-reached level matters!

4. Position - looks at the order that the rules were defined in 
  -rules that are defined later in linked stylesheets or <style> tags will win, given that everything else in the cascade is the same

Official chrome devTools doc:
-Animation group: group of animations that appear to be related to each other 

Box model: 
-everything on a webpage is a rectangular box 
-these boxes can have other boxes in them, and can sit alongside one another 
-content box = area where your content is displayed, can be resized using width and height
-padding = the whitespace between the text/content and the edge of the border
-border = outlines/wraps the content and padding
-margin = the whitespacespace between the border and the edge of the window and other elements
  -shorthand property that can accept up to 4 values: margin-top, margin-right, margin-bottom, margin-left
  -if fewer than four values set, missing values will be assumed based on the ones defined 
  -can use auto keyword, useful for horizontal centering (will not center an element vertically)
  -vertical margins will collapse, forming a single margin that is equal to the greater of the adjoining margins 
  -negative margines will pull the element itself in that direction, or pull other elements towards it
-can turn on alternative box model for an element
  -box-sizing: border-box;
  -this will allow height and width declared be the true height and width of the element 
  -in the standard css box model, the actual space = height/width + margin + padding + border
-block vs in-line display types
  -block 
    -box will break onto new line
    -box will extend in the inline direction to fill the space available in its container = box will become as wide as its container 
    -width and height properties are respected, padding, margin, and border will cause other elements to be pushed further away from the box
    -<h1> and <p> use block as their outer display type by default
  -inline 
    -box will not break into new line 
    -width and height properties will not apply
    -vertical padding, margins, and borders will apply but will not cause other inline boxes to move away from the box
    -horizontal padding, margins, and borders will apply and will cause other inline boxes to move away from the box
    -<a>, <span>, <em>, <strong> use inline as their outer display type by default
  -inline-block
    -where you do not want an item to break into a new line, but want to respect width and height 
  -ex. https://www.digitalocean.com/community/tutorials/css-display-inline-vs-inline-block
  -can hardcode changes using display: block, displauy: inline, display: inline-block

-Divs and Spans
  -give no particular meaning to their content, unlike Paragraphs 
  -they are just generic boxes and contain anything
  -span is an inline-level element by default, commonly used to group text content and inline HTML elements so we can apply styling to them 
    ex. highlight text, including a link
  
The normal layout flow is the system by which elements are placed inside the browser's viewport 
  -block level elements are laid out in the block flow direction 
    -each element will appear on a new line below the last one, with each separated by whatever margin is specified 
  -inline elements behave differently, they don't appear on new lines
    -they sit on the same line along with adjacent text as long as there is space for them 
    -if not enough space, overflowing content will move down to the next line
  
Flexbox
  -flexbox is a way to arrange items into rows, columns, where those items will flex (grow/shrink) based on rules you can defined
  -a flex container is any element that has display:flex on it, and a flex item is any element that lives directly inside of a flex container
  -flex items can also become flex containers if you put display: flex, on a flex item 
  -can build complex layouts by creating and nesting multiple flex containers and items 
  -some initial values are defined, all contained flex items will behave in the following way:
    -display in a row
    -items start from the start edge of the main axis 
    -items do not stretch on the main axis dimension, but can shrink
    -items will stretch to fill the size of the cross axis 
    -flex-basis set to auto, flex-wrap set to nowrap 
  
Growing/shrinking with Flexbox
  -flex declaration is shorthand for 3 properties you can set
    -flex-grow (default 0) - "growth factor" 
      -if we applied flex: 1 to every div, we are telling every div to grow the same amount
        -will make each of the items grow to fill the available space, equally shared between the items to fill the container on the main axis
      -if we add flex: 2 to just one of the divs, then that div would grow to 2x the size of the other flex items 
        -flex-grow can be used to distribute space in proportion 
        -if flex: 2 on one item, and flex:1 on other items, 2 parts of the available space given first item, 1 part to other two 
    -flex-shrink (default 1) - "shrink factor"
      -in contrast to flex-grow, flex-shrink will control how space is taken away
      -will only really be applied if the size of the flex items is larger than the flex (parent) container 
      -default = 1, which means all items will shrink evenly 
      -if you do not want an item to shrink, can specify with flex-shrink: 0;
      -can specify higher numbers to make certain items shrink at a higher rate than normal 
      -*important to note that flex items do not necessarily respect width values.. if their parent is big enough, will grow to fit. If parent is too small, will shrink to fit 
    -flex-basis (default auto)
      -sets the initial size of a flex item 
      -defines the size of that item in terms of the space it leaves as available space 
      -the browser looks to see if the items have a size 
        -if it does, it uses that size as the flex-basis 
      -if items do not have a size, then the content's size is used as the flex-basis
  -shorthand notation:
    -flex:initial == flex: 0 1 auto
    -flex:auto == flex: 1 1 auto
    -flex: none == flex: 0 0 auto

Axes of a flex container 
  -default direction for a flex container = horizontal, or a rows --> runs in the inline direction
  -can change the direction to vertical, or a column  --> runs in the block direction 
    -use flex-direction: column 
  -there is also row-reverse and column-reverse
  -Need to think of flex-containers as having 2 axes: main axis and cross axis 
    -cross axis runs perpendicular to the main axis 
    -direction of these axes changes when flex-direction is changed 
    -flex-direction: row places main axis horizontal, and flex-direction: column places main axis vertical 
  -block level elements default to the full width of their parents
  -when changing things to vertical using flex-direction: column, this adds complexity because block level elements default to the height of their content
  -another note is that when changing flex-direction to column, flex-basis refers to height instead of width with flex-direction: row
    -empty elements will have a height of 0, and so for flex items to fill up the height of the container, they don't need height at all so will see collapse 

  
Alignment 
  -justify-content: center will align boxes in the center along the main axis 
    -can use flex-start, flex-end, center, space-between (take all the spare space after all items have been laid out and share it evenly between items so there is equal amount of space between each item), space-around(items have half-size space on either end), space-evenly (items have a full-size space on either end)
  -align-items: center can be used to change placement of items along the CROSS axis 
    -flex-start(make items line up at the start of the flex container), flex-end (align them to the end of the flex container), center (align them to the center of the flex container), and stretch can all be used as values for the align-items property 
  -align-content: sets how multiple lines are spaced apart from each other
    -flex-start: lines packed to the start of the container
    -flex-end: lines packed to the end of the container
    -center: lines packed 

Gap 
  -gap property simply adds a specified space between flex items, similar to adding a margin to the items themselves
  -there is also column-gap and row-gap properties 
    -column-gap property creates gaps between items on the main axis
    -row-gap property creates gaps between flex lines (on the cross axis)
    -gap is shorthand that sets both together 

Flex-wrap
  -flex items can wrap onto multiple lines, using the flex-wrap: wrap property 
  -if items are too large to display in one line, will wrap onto another line 
  -can combine flex-direction and flex-wrap with the flex-flow:row wrap shorthand 

Flexbox cheatsheet: https://css-tricks.com/snippets/css/a-guide-to-flexbox/

Javascript
-can use an external script to link into HTML
-<script src="script.js"></script>

-comparisons:
  -when comparing strings, will be compared lexicographically via unicode 
  -using '==' = regular equality check 
  -using '===' = strictly equals, checks equality without type conversion \

  -true == 1 --> true; //truthy value 
  -true === 1 --> false
  -false == 0 --> true; //falsy value
  -false ===0 --> false

  -comparing null and undefined
    -null === undefined --> false
    -null == undefined --> true
  
  -equality check (==) and comparisons (< > >= <=) work differently 
    -with null: 
    -comparisons covert null to a number, treating it as 0
    -equality checks do not perform conversions
    ex. null > 0 --> false || null == 0 --> false || null >= 0 --> true

    -but with undefined:
      -undefined > 0 --> false || undefined < 0 --> false
        -undefined gets converted to NaN, and NaN is a special numeric number value which returns false for all comparisons 
      -undefined == 0 --> false
        -undefined only equals null, undefined, and no other value
  
  -null --> represents "nothing", "empty" or "value unknown"
  -undefined --> represents "value is not assigned"

  -ternary operator "?"
    -has 3 operands... syntax is:
      let result = condition ? value1 : value2
    -the condition is evaluated... if it is truthy, value 1 is returned
      -else value 2 is returned 
  -multiple ternaries 
    ex.
    let age = prompt ("age?",18);
    let message = (age < 3) ? "high baby!" :
        age < 18 ? "Hello!" :
        age < 100 ? "Greetings" :
        "You're over 100?!"
    -if age < 3, will say high baby. if < 18 but >3, will say Hello
    -if >18 but <100 will say Greetings
    -else will say youre over 100?!

  -switch statement
    -evaluates an expression and executes code as a result of a matching case
    -syntax:
      switch (expression) {
        case x: //x is tested against an expression, if matches, will execute code in case x code block
          //execute case x code block
          break; --> will end switch block 
        case y:  //if it does not match x, will test case y against the expression
          //execute case y code block;
          break;
        default:
          //execute default code block if none of the cases match
      }
    -can use switch ranges 
      ex. 
      const grade = 87;

      switch (true){
        case grade >=90:
          console.log("A");
          break;
        case grade >=80:
          console.log("B");
          break;
        etc..
      }
    -can also use multiple cases 
      ex.
      const month = new Date().getMonth(); //will return a number from 0 to 11
        //0 = january, 11 = december
      switch (month){
        case 0:
        case 1:
        case 2:
          console.log("winter");
          break;
        case 3:
        case 4:
        case 5:
          console.log("Spring");
          break;
        etc...
      }

-javascript events 
  -need to write javascript code that reacts to these events 
  -each element in the DOM have event properties 
  -ex. 
    -need to get the element and store in variable
    -let title = document.getElementById("page-title");
      -now this variable has access to all of the event properties
    -title.onclick = function(){
      alert("you clicked me");
    };
      -when clicking the title, then will run this function and execute alert 
    -title.onmouseover = function(){
      alert("you hovered your mouse over me");
    };
  -can use event listeners
    -addEventListeners();
  
  -onLoad event!
  -window.onLoad = function(){

  };
  -the window object represents to the browser window
  -this means, once the browser window has loaded, then running the function
  -this will be needed at times, because if your script manipulates the HTML, will need the entire HTML to be loaded first 
  -otherwise, the script will not know which tags are declared or their values

-javascript timers 
  -setTimeout
  -setInterval
  -stopping the timers:
    -clearTimeout
    -clearInterval
    -this will require you to store the timeout or interval in a variable when setting interval/timeout 

-Accessing form elements
-document.forms.formName;
-can then access the different inputs' values using:
  -formName.name.value

-Form validation
  -can perform client side validation using the onSubmit event, prevent from sending to server side and save time, in the case when certain parameters are not met
  -can prevent form from being submitted but returning false
  -if want to submit form, can return true on the onSubmit 

-Javascript libraries -- code that has already been written we can utilize for our own project 
  -jquery is a very popular library
  -can use content delivery network (CDN)

Functions
-Functions that are part of objects = methods
-Some functions require parameters to be specified when invoking them
-return values:
  -values that a function returns when it has completed 
  -some functions don't return any value
  -after function code reaches a return, will exit the function
  -do not need to return anything 
  -if you return nothing, or do not have a return statement, it will automatically return "undefined"
-function naming: 
  -"get.." -- return a value
  -"calc.." - calculate something
  -"create..." - create something
  -"check..." check something and return boolean, etc.
-one function, one action - should do exactly what is suggested by its name 
-can use function declarations or function expressions to create a function


//using prompt, confirm
function checkAge(age) {
if (age >= 18) {
  return true;
} else {
  return confirm('Do you have permission from your parents?');
  }
}
let age = prompt('How old are you?', 18);
if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}

PROBLEM SOLVING
1. UNDERSTAND THE PROBLEM
-Know exactly what is being asked 
-If you don't understand the problem, you won't know when you have successfully solved that problem
-When you can explain the problem to someone else in plain English, you understand it

2. PLAN 
-Does your program have a user interface? What will it look like, what functionality will it have?
-What inputs will your program have? Will the user input data or will the input come from somewhere else?
-What is the desired output?
-Given the inputs, what are the necessary steps to return the desired output?

2b. PSEUDOCODE 
-Write the logic for your problem in natural language instead of code

4. DIVIDE AND CONQUER 
-Identify subproblems of the big problem you are solving 
-This can be done during the pseudocoding 
-Do not try to solve the big problem in one go 
-Decomposition is the main way to deal with complexity, making problems easier and more approachable to solve and understand 
-connecting all of your "sub-solutions" will give you the solution to the original problem 

5. GET UNSTUCK
-Take a deep breath, it happens
-Be curious about the bugs/errors
-Debugging!
-Reassess - look at the problem from another perspective
-Research - learn how to Google correctly! No matter what problem you have, someone has probably solved it before 

6. PRACTICE


using a new branch here

